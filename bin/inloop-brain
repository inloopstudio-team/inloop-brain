#!/usr/bin/env ruby

# bin/inloop-brain - A command-line tool to interact with the Inloop Brain API (OpenAI-compatible)

$LOAD_PATH.unshift(File.expand_path("../lib", __dir__))

require 'optparse'
require 'net/http'
require 'uri'
require 'json'
require 'inloop_brain/ssl'

# Parse command line options
options = {}
parser = OptionParser.new do |opts|
  opts.banner = "This is the Inloop Brain CLI\n\n  Usage: inloop-brain [options]"
  opts.on('-k KEY', '--key=KEY', 'API key for the Inloop Brain (OpenAI-compatible)') do |key|
    options[:key] = key
  end
  opts.on('-m MODEL', '--model=MODEL', 'Model name (default: inloop-brain)') do |model|
    options[:model] = model
  end
  opts.on('--system=TEXT', 'System prompt to prepend to the conversation') do |text|
    options[:system] = text
  end
  opts.on('--api-url=URL', 'Override API URL (default: https://app.inloop.studio/api/v1/chat/completions)') do |url|
    options[:api_url] = url
  end
  opts.on('-d', '--debug', 'Enable debug mode') do
    options[:debug] = true
  end
  opts.on('-h', '--help', 'Display this help message') do
    puts opts
    exit
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption => e
  STDERR.puts e.message
  STDERR.puts parser
  exit 1
end

# Validate required parameters
options[:key] ||= ENV['INLOOP_BRAIN_API_KEY']
unless options[:key]
  STDERR.puts "Error: Missing required parameter 'key' (or set INLOOP_BRAIN_API_KEY)"
  STDERR.puts parser
  exit 1
end

# Read input from STDIN
input = STDIN.read.strip

# Exit if no input provided
if input.empty?
  STDERR.puts "Error: No input provided via STDIN"
  exit 1
end

# Configure the API request
api_url = options[:api_url] || ENV['INLOOP_BRAIN_API_URL']
if api_url.nil? || api_url.strip.empty?
  host = ENV['INLOOP_BRAIN_HOST'] || 'app.inloop.studio'
  protocol = ENV['INLOOP_BRAIN_PROTOCOL'] || 'https'
  api_url = "#{protocol}://#{host}/api/v1/chat/completions"
end
uri = URI.parse(api_url)

if options[:debug]
  puts "Making request to: #{uri}"
end

# Setup the HTTP request
http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = (uri.scheme == 'https')

# Some environments enable CRL checking globally for TLS verification but do not
# provide the CRLs, causing OpenSSL to abort with:
#   "certificate verify failed (unable to get certificate CRL)"
# We keep certificate verification enabled, but soft-fail only those CRL-missing
# errors by default. Set INLOOP_BRAIN_SSL_STRICT=1 to disable this compatibility
# behavior.
if http.use_ssl?
  http.verify_mode = OpenSSL::SSL::VERIFY_PEER
  http.verify_hostname = true if http.respond_to?(:verify_hostname=)

  strict_ssl = ENV.fetch('INLOOP_BRAIN_SSL_STRICT', '').to_s.downcase
  strict_ssl = %w[1 true yes].include?(strict_ssl)
  unless strict_ssl
    http.verify_callback = InloopBrain::SSL.allow_missing_crl_verify_callback(debug: options[:debug])
  end
end

# Add proper timeout settings
http.open_timeout = 10
http.read_timeout = 60

request = Net::HTTP::Post.new(uri)
# Set proper headers
request['Content-Type'] = 'application/json'
request['Accept'] = 'application/json'
request['Authorization'] = "Bearer #{options[:key]}"
request['User-Agent'] = 'Inloop-Brain-CLI/0.0.10'

messages = []
messages << { role: 'system', content: options[:system] } if options[:system].to_s.strip != ''
messages << { role: 'user', content: input }
body = {
  model: options[:model] || ENV['INLOOP_BRAIN_MODEL'] || 'inloop-brain',
  messages: messages
}
request.body = JSON.dump(body)

# Send the request and handle the response
begin
  if options[:debug]
    puts "Request headers:"
    request.each_header { |key, value| puts "  #{key}: #{value}" }
    puts "Request body: #{request.body}"
  end
  
  response = http.request(request)
  
  if options[:debug]
    puts "Response status: #{response.code}"
    puts "Response headers:"
    response.each_header { |key, value| puts "  #{key}: #{value}" }
  end
  
  begin
    payload = JSON.parse(response.body.to_s)
  rescue JSON::ParserError
    payload = nil
  end

  if response.code.to_i == 200
    content = payload.dig("choices", 0, "message", "content") if payload
    content ||= payload.dig("choices", 0, "text") if payload
    if content
      puts content
    else
      STDERR.puts "Error: Unexpected response format"
      STDERR.puts response.body
      exit 1
    end
  else
    message = payload.dig("error", "message") if payload
    STDERR.puts "Error: API returned status code #{response.code}"
    STDERR.puts(message || response.body)
    exit 1
  end
rescue => e
  STDERR.puts "Error: Failed to connect to the API: #{e.message}"
  STDERR.puts e.backtrace.join("\n") if options[:debug]
  exit 1
end
